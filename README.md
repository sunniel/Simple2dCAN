# Overview

## Introduction

A simple OMNet++ simulation of the the peer-to-peer content addressable network (CAN) protocol [1], which only implement a 2-dimensional CAN (i.e., 2-d CAN).

**Node** that for node dynamics, only the *immediate zone takeover* algorithm [1] is implemented (with *expanding ring search* for neighbor discovery) in the maintenance routine. The *zone re-assignment* algorithm [1] hasn't been implemented, which is left for future work, as well as the *zone overload* [1] algorithm. 

So, in simulation ,if a node zone takes multiple zones and later fails, all the zones previously managed by the node could be taken over by several neighbors, and these neighbors may not realize the existing of each other. In this case, new neighbors can only be discovered through *expanding ring search*. Otherwise, nodes view and the entire overlay could be inconsistent. This problem can be mitigated through (periodic) zone re-assignment.

Due to its simple implementation, it can be easily plugged in as an individual module within a larger project, such as in [VirtualWorldContentSharing](https://github.com/sunniel/VirtualNetContentSharing).

## Simulation environment and 3rd-party dependency: 

1. OMNet++ 5.4 or later (supporting c++ 11)

2. Boost C++ libraries (1.66.0, https://www.boost.org/)

3. JSON for Modern C++ (https://github.com/nlohmann/json)

## Source Codes

### Source Code Directory Structure

All source codes can be found under the /src/ directory, which contains the following sub-directories.

abstract/: contains the overall simulation network description file.

app/: contains the application layer protocol, currently unused.

common/: contains the commonly used base class the the utility functions

crypto/: contains the hash code generation implementation

global/: contains the global simulation modules for   
1. lookup traffic generation (TrafficGenerator), 
2. churn generation (UniformChurnGenerator),  
3. manual node removal (ManualChurnGenerator), 
4. statistical result collection (GlobalStatistics), 
5. global node IP address lookup for message transmission (GlobalNodeList), 
6. manual data distribution/lookup (ContentDistributor),
7. underlay and overlay network initialization (UnderlayConfigurator),
8. simulation parameters (GlobalParameters).

ctrl/: CAN protocol implementation module, used by all CAN hosts

hosts/: composite CAN node

messages/: CAN message definition

objects/: data object used by each CAN node, which contains:  
1. CAN information (CANInfo), used by GlobalNodeList for ID-address mapping
2. CAN profile (CANProfile)
2. IPAddress

others/: contains the network interface module used by hosts, currently unused.

transport/: contains the transport modules used by hosts  
1. reliable UDP: no message drop, which may generate higher latency for message re-transmission (ReliableUDP)
2. unreliable UDP: message transmission could be failed due to message drop, currently unused (SimpleUDP) 

## Configurations (/simulations/omnetpp.int)

### CAN Protocol Parameters:

\# length of CAN ID in binary  
**.globalParameters.address_space_size = 20

\# maximum horizontal/vertical (i.e., X/Y) scale; thus the entire CAN area is can_area_size * can_area_size  
**.globalParameters.can_area_size = 100000000  

\* maximum number of hops in CAN lookup to avoid live lock  
**.globalParameters.max_hop = 50

\* the maximum hop in a expanding ring search  
**.globalParameters.ers_threshold = 4

### Simulation parameters

\# CAN overlay network initial size  
**.globalParameters.can_init_size = 100

\# for manual CAN node removal, referring to ManualChurnGenerator  
**.churnGenerator.scan_cycle = 100ms

\# cycle of network churn, referring to UniformChurnGenerator  
**.churnGenerator.churn_cycle = 10s

\# node departure/arrival rate, used by UniformChurnGenerator  
**.churnGenerator.depart_rate = 0.1  
**.churnGenerator.arrival_rate = 0.1

\# Maximal/minimal overlay size, used by UniformChurnGenerator
**.churnGenerator.overlay_size_max = 500
**.churnGenerator.overlay_size_min = 10

\# CAN lookup request generation cycle
**.trafficGenerator.traffic_cycle = 5000ms

\# CAN maintenance cycle to fix finger tables and successor lists, called by each CAN node
**.can[*].ctrl.maintain_cycle = 1000ms

### Parameters for Message Transmission

\# Propagation delay generation mode.  
\# 0: Simulation of real-world propagation delay generated by 1) light transmission limit, 2) communication congestion, and 3) jitter  
\# 1: Propagation delay with minimal singl-trip latency (Dmin) and jitter, i.e., Dmin + jitter 
**.globalParameters.latency_gen_mode = 1

\# maximum distance could be, for example, half of the Earth circumference: 20000000m
**.globalParameters.max_distance = 20000000m  

\# packet loss rate  
**.pktLossRate = 0.01

\# 2/3 of the light speed  
**.Copt = 200000000mps  

\# 10 mega bits per second  
**.BW = 1.04858e6bps  

\# Ethernet packet size 1518 Bytpes = 12144 bits  
**.MTU = 12144b  
**.jitter_mu = 1  
**.jitter_sigma = 0.5  

\# minimal end-to-end delay
**.Dmin = 50ms
**.jitter = 50ms

# References:
[3] Ratnasamy, S., Francis, P., Handley, M., Karp, R., Shenker, S.: "A scalable content-addressable network"; *Proc. SIGCOMM '01*, ACM, New York (2001), 161-172. 

---

# Contacts: 
[1] Ratnasamy, S., Francis, P., Handley, M., Karp, R., Shenker, S.: "A scalable content-addressable network"; *Proc. SIGCOMM '01*, ACM, New York (2001), 161-172. 